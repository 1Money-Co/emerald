//! Extract UUPS `__self` immutable reference offsets from the Foundry build artifact.
//!
//! The ValidatorManager contract uses UUPS (ERC1822) which stores an immutable
//! `__self = address(this)` set during construction. When genesis injects deployed
//! bytecode directly (bypassing the constructor), these locations must be patched.
//! This build script reads the offsets from the Foundry JSON artifact so they stay
//! in sync automatically after every `forge build`.

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let artifact_path = Path::new("../solidity/out/ValidatorManager.sol/ValidatorManager.json");

    // Re-run if the artifact changes (i.e. after `forge build`)
    println!(
        "cargo::rerun-if-changed={}",
        artifact_path.display()
    );

    let json_str = fs::read_to_string(artifact_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read Foundry artifact at {}: {e}. Run `forge build` in the solidity/ directory first.",
            artifact_path.display()
        )
    });

    let artifact: serde_json::Value =
        serde_json::from_str(&json_str).expect("failed to parse Foundry artifact JSON");

    let refs = artifact["deployedBytecode"]["immutableReferences"]
        .as_object()
        .expect("missing deployedBytecode.immutableReferences in artifact");

    // Collect all (offset, length) pairs across all immutable IDs.
    // For ValidatorManager there is exactly one immutable (__self from UUPSUpgradeable).
    let mut offsets: Vec<usize> = Vec::new();
    let mut length: Option<usize> = None;

    for (_ast_id, locations) in refs {
        for loc in locations.as_array().expect("immutable locations should be an array") {
            let start = loc["start"]
                .as_u64()
                .expect("immutable reference missing 'start'") as usize;
            let len = loc["length"]
                .as_u64()
                .expect("immutable reference missing 'length'") as usize;

            // All references to the same immutable have the same length
            if let Some(prev) = length {
                assert_eq!(prev, len, "inconsistent immutable reference lengths");
            }
            length = Some(len);
            offsets.push(start);
        }
    }

    offsets.sort();

    assert!(
        !offsets.is_empty(),
        "no immutable references found in ValidatorManager artifact"
    );

    let length = length.unwrap();

    // Generate Rust source
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("uups_immutable_offsets.rs");

    let offsets_str = offsets
        .iter()
        .map(|o| o.to_string())
        .collect::<Vec<_>>()
        .join(", ");

    let generated = format!(
        "/// Byte offsets of the UUPS `__self` immutable in ValidatorManager DEPLOYED_BYTECODE.\n\
         /// Auto-generated by build.rs from the Foundry artifact.\n\
         pub const UUPS_SELF_IMMUTABLE_OFFSETS: &[usize] = &[{offsets_str}];\n\
         \n\
         /// Byte length of each immutable reference (address left-padded to 32 bytes).\n\
         pub const UUPS_SELF_IMMUTABLE_LENGTH: usize = {length};\n"
    );

    fs::write(&dest, generated).expect("failed to write generated offsets file");
}
